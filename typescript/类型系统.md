### 鸭子类型/结构类型
1. 在结构化的类型系统中，如果两个对象具有相同的结构，则认为它们是相同的

### 类型分类
1. [[typescript/类型系统/类型的分类|类型的分类]]

### 类型操作
1. [[typescript/类型系统/类型的操作|类型的操作]]

### 函数相关
1. [[typescript/类型系统/函数相关|函数相关]]

### 声明类型的方式（两种）
| 关键字       | 解释           | 可追加属性 |
| --------- | ------------ | ----- |
| type      | 类型别名，可声明复杂类型 | 否     |
| interface | 接口，声明结构化类型   | 是     |
接口追加属性例子：
```typescript
interface Window {
  title: string
}
// 可以向现有接口追加字段，但type不能
interface Window {
  ts: TypeScriptAPI
}  
const src = 'const a = "Hello World"';
window.ts.transpileModule(src, {});
```

### 泛型
1. 本质是给类型提供变量
2. extends 约束条件
```typescript
// 函数中使用泛型
function longest<Type>(a: Type, b: Type) {
	...
}
longest<number>(1, 2)
// 或者
longest(1, 2) // 可以通过参数自动推断出的type，可以不用指定类型参数

// interface中使用泛型
interface Window<T> {
  title: T;
}

// type中使用泛型
type User<T> = Array<T>

// 泛型约束
function longest<Type extends { length: number }>(a: Type, b: Type) {
	...
}
```

##### 联合类型
1. 由两个或多个类型组合而成的新类型，其值是其中任意的一种类型
2. 如果所有类型都有同一个属性，则使用该属性不需要确认具体属于哪个类型

##### 类型断言
1. as 缩小值的类型范围，例：const a = b as number
2. ! 该值不是null和undefined，例：obj!.name

##### 类型守卫
1. 目的是进行 类型收窄：将类型细化为比声明类型更精确的类型，当类型收窄到排除所有可能类型时，变成never类型
2. 比如判断是否等于
3. typeof a = "number"
4. "aa" in User
5. “aa” instanceof User
6. 类型谓词 is，用于在函数返回类型中定义 parameterName is User，其中parameterName必须是函数中的参数名，User必须是该参数类型范围中，例：
```typescript
function isFish(pet: Fish | Bird): pet is Fish {
	return (pet as Fish).swim !== undefined;
}
```

##### 函数this类型
1. 规定函数体中this类型，同时规范了外部调用环境
```typescript
// 定义第一个参数名为this的类型
function (this: User) {
	return this.admin;
}

// ×××××××××箭头函数不能包含 "this" 参数××××××××××
const testFun = (this: string) => {
	...
}
```

##### 类型组合
1. 使用interface扩展，同名属性不同类型的属性会报错
2. 创建交叉类型，同名属性不同类型的属性会变成never类型
```typescript
// interface扩展，继承其它接口已有的属性
interface ColorfulCircle extends Colorful, Circle {}

// 交叉类型
type ColorfulCircle = Colorful & Circle;
```