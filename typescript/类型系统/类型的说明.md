### 声明类型（两种方式）
| 关键字       | 解释                                     | 可追加属性 |
| --------- | -------------------------------------- | ----- |
| type      | [[typescript/类型系统/类型别名\|类型别名]]，可声明复杂类型 | 否     |
| interface | 接口，声明[[typescript/类型系统/结构化类型\|结构化类型]]  | 是     |
接口追加属性例子：
```typescript
interface Window {
  title: string
}
// 可以向现有接口追加字段，但type不能
interface Window {
  ts: TypeScriptAPI
}
const src = 'const a = "Hello World"';
window.ts.transpileModule(src, {});
```

### 泛型
1. 可以理解给类型提供变量

#### 定义泛型
```typescript
// 函数中使用泛型
function longest<Type>(a: Type, b: Type) {
	...
}
longest<number>(1, 2)
// 或者
longest(1, 2) // 可以通过参数自动推断出的type，可以不用指定类型参数

// interface中使用泛型
interface Window<T> {
  title: T;
}

// type中使用泛型
type User<T> = Array<T>

// 类中使用
class GenericNumber<NumType> {
	zeroValue: NumType;
	add: (x: NumType, y: NumType) => NumType;
}
```

#### 泛型约束
```typescript
// 泛型约束，关键字 extends
function longest<Type extends { length: number }>(a: Type, b: Type) {
	...
}
```

#### 泛型默认值
```typescript
declare function create<T extends HTMLElement = HTMLDivElement, U extends HTMLElement[] = T[]>(
	element?: T,
	children?: U
): Container<T, U>;
```

### 类型收窄
1. 将类型细化为比声明类型更精确的类型，当类型收窄到排除所有可能类型时，变成never类型

#### 类型断言
1. 值类型未明确时，指定值的类型

| 关键字 | 说明                 | 示例                    |
| --- | ------------------ | --------------------- |
| as  | 缩小类型范围             | const a = b as number |
| !   | 该值不是null和undefined | obj!.name             |

#### 类型守卫
1. 值类类型未明确时，判断值的类型

| 关键字             | 说明                     | 示例                       |
| --------------- | ---------------------- | ------------------------ |
| \=\=\= \| \!=\= | 判断是否等于                 | "a" \=\=\= "a"           |
| typeof          | 获取类型字符串进行比较            | typeof a \=\=\= "number" |
| in              | 检查对象自身及其原型链是否存在指定属性或方法 | “aa” in User             |
| instanceof      | 对象是否通过特定构造函数创建         | aa instanceof User       |
| 类型谓词 is         | 创建可以判断类型的函数            | [[#带类型谓词返回值函数]]          |
##### 带类型谓词返回值函数
```typescript
function isFish(pet: Fish | Bird): pet is Fish {
	return (pet as Fish).swim !== undefined;
}
```

### 类型组合

| 方式   | 说明                    | 示例               |
| ---- | --------------------- | ---------------- |
| 接口扩展 | 同名属性不同类型的属性会报错        | [[#interface扩展]] |
| 交叉类型 | 同名属性不同类型的属性会变成never类型 | [[#创建交叉类型]]      |
#### interface扩展
```typescript
// interface扩展，继承其它接口已有的属性
interface ColorfulCircle extends Colorful, Circle {}
```

#### 创建交叉类型
```typescript
// 交叉类型
type ColorfulCircle = Colorful & Circle;
```

### keyof
1. 生成一个对象键值组成的联合类型
```typescript
type Point = { x: number; y: number };
type P = keyof Point; // "x" | "y"

type Arrayish = { [n: number]: unknown };
type A = keyof Arrayish; // number

type Mapish = { [k: string]: boolean };
type M = keyof Mapish; // string | number
```

### 条件类型
1. 通过条件真假返回不同类型，类似js中的三元运算符

```typescript
type NameOrId<T extends number | string> = T extends number ? IdLabel : NameLabel;
```

### infer
1. 推理指定位置的类型

```typescript
// 获取函数返回值类型
type GetReturnType<Type> = Type extends (...args: never[]) => infer Return? Return : never;
type Num = GetReturnType<() => number>; // number

// 获取数组元素类型，存在多个类型时返回元素类型组成的联合类型
type Flatten<Type> = Type extends Array<infer Item> ? Item : Type;
```