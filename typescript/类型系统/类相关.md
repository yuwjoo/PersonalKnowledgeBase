### 成员修饰符
```typescript
class User {
	public name: string; // 任何地方都可以访问
	protected age: number; // 仅类中或子类中可以访问
	private sex; // 仅本类可以访问
}
```

### 定义泛型
```typescript
class Box<Type> {
	contents: Type;

	constructor(value: Type) {
		this.contents = value;
	}
}

```

### 实现接口
1. 不会改变类原本的属性行为

```typescript
interface Pingable {
	ping(): void;
}

class Sonar implements Pingable {
	ping() {
	console.log("ping!");
	}
}
```

### 继承基类
```typescript
class Animal {
	move() {
	console.log("Moving along!");
	}
}

class Dog extends Animal {
	woof(times: number) {
		for (let i = 0; i < times; i++) {
			console.log("woof!");
		}
	}
}
```

#### 仅类型字段声明
1. 用于覆盖基类字段的类型，但又不想真的重新定义这个字段
```typescript
class AnimalHouse {
	resident: Animal;
	
	constructor(animal: Animal) {
		this.resident = animal;
	}
}

class DogHouse extends AnimalHouse {
	declare resident: Dog; // 重新定义该字段类型，但不会对运行时产生影响

	constructor(dog: Dog) {
		super(dog);
	}
}
```

### 类中使用箭头函数代替成员方法
1. 内部上下文永远指向该实例
2. 每个实例都会创建一次该函数的副本，造成内存占用过多
3. 在派生类中使用super.getName调用不到该函数（原型链中不存在基类成员变量）

### 参数属性
1. 通过在构造函数参数前天添加修饰符，会自动在类中创建对应属性
```typescript
class Params {
	constructor(
		public readonly x: number,
		protected y: number,
		private z: number
	) {
	// No body necessary
	}
}

const a = new Params(1, 2, 3);
console.log(a.x); // 此时x属性被自动创建并赋值
```

### 类表达式
1. 通过赋值的方式创建类
```typescript
const someClass = class<Type> {
	content: Type;

	constructor(value: Type) {
		this.content = value;
	}
};

const m = new someClass("Hello, world");
```

### abstract
1. ts中类，方法，字段可以是抽象的
2. 抽象类是未提供实现的类
3. 当一个类没有任何抽象成员时，就是一个具体类

```typescript
// 定义抽象类
abstract class Base {
	abstract getName(): string;

	printName() {
	console.log("Hello, " + this.getName());
	}
}
```